<script>
  class NormalRunner {
    constructor(parser) {
      this.parser = parser;
      this.handles = [];

      this.HACK_FIRST_WAIT_MS = 250;
    }

    run({ ast, request, throttle, callbacks }) {
      const states = this._interpret(ast, request);
      this._runWithThrottle(states, throttle, callbacks);
    }

    clear() {
      this.handles.forEach(clearInterval);
      this.handles = [];
    }

    _runWithThrottle(states, throttle, { onResult, onStop }) {
      const _onResult = (state) => onResult(state.board || state, state);

      if (throttle === 0) {
        const lastState = _.last(states);
        _onResult(_.last(states));
        return onStop("end");
      }

      const firstState = _.first(states);
      _onResult(_.first(states));
      if (states.length === 1) return onStop("end");

      setTimeout(() => {
        this.handles = states.slice(1).map((state, i) => {
          const ii = i + 1;

          return setTimeout(() => {
            _onResult(state);
            if (ii === states.length - 1) onStop("end");
          }, ii * throttle)
        });
      }, this.HACK_FIRST_WAIT_MS); // TODO: Pensar soluciÃ³n mejor
    }

    _interpret(ast, { initialState, code }) {
      try {
        var result = this.parser.interpret(ast.program, initialState);
        return this._getStates(result, ast.teacher);
      } catch (e) {
        e.location = this.parser.getErrorLineAndMode(e, code);
        return this._getStates(e, ast.teacher, { error: e });
      }
    }

    _getStates(result, teacherAst, lastState = []) {
      const teacherTools = teacherAst.declarations
        .filter(it => _.includes(["procedureDeclaration", "functionDeclaration"], it.alias))
        .map(it => it.name);

      const snapshots = result.snapshots;

      return snapshots
        .filter((snapshot, i) => {
          const toName = (it) => it.split("-")[0];

          const prevNames = _.take(snapshot.contextNames, snapshot.contextNames.length - 1);
          const lastName = _.last(snapshot.contextNames)

          let topIgnoredName = _.find(prevNames, (it) =>
            _.includes(teacherTools, toName(it))
          ) || lastName;

          const hasToIgnoreIt = _.includes(teacherTools, toName(topIgnoredName));

          const isTheLastOcurrence = _.every(snapshots.slice(i + 1), futureSnapshot =>
            !_.includes(futureSnapshot.contextNames, topIgnoredName)
          );

          const isShowable = !hasToIgnoreIt || isTheLastOcurrence;

          return isShowable;
        }).concat(lastState);
    }
  }
</script>
