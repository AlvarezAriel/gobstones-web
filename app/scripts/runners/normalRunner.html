<script>
  class NormalRunner {
    constructor(parser) {
      this.parser = parser;
      this.handles = [];
    }

    run({ ast, request, throttle, callbacks }) {
      const states = this._interpret(ast, request);
      this._runWithThrottle(states, throttle, callbacks);
    }

    clear() {
      this.handles.forEach(clearInterval);
      this.handles = [];
    }

    _runWithThrottle(states, throttle, { onResult, onStop }) {
      if (throttle === 0) {
        onResult(_.last(states));
        return onStop("end");
      }

      this.handles = states.map((state, i) =>
        setTimeout(() => {
          onResult(state);
          if (i === states.length - 1) onStop("end");
        }, i * throttle)
      );
    }

    _interpret(ast, { initialState, code }) {
      try {
        var context = this.parser.interpret(ast.program, initialState);
        return this._getStates(context, ast.teacher, context.board());
      } catch (e) {
        e.location = this.parser.getErrorLineAndMode(e, code);
        return this._getStates(e.context, ast.teacher, { error: e });
      }
    }

    _getStates(context, teacherAst, lastState) {
      const teacherTools = teacherAst.declarations
        .filter(it => _.includes(["procedureDeclaration", "functionDeclaration"], it.alias))
        .map(it => it.name);

      const snapshots = context.board().snapshots;

      return snapshots
        .filter((snapshot, i) => {
          const toName = (it) => it.split("-")[0];

          const prevNames = _.take(snapshot.names, snapshot.names.length - 1);
          const lastName = _.last(snapshot.names)

          let topIgnoredName = _.find(prevNames, (it) =>
            _.includes(teacherTools, toName(it))
          ) || lastName;

          const hasToIgnoreIt = _.includes(teacherTools, toName(topIgnoredName));

          const isTheLastOcurrence = _.every(snapshots.slice(i + 1), futureSnapshot =>
            !_.includes(futureSnapshot.names, topIgnoredName)
          );

          const isShowable = !hasToIgnoreIt || isTheLastOcurrence;

          return isShowable;
        }).map(snapshot => snapshot.board).concat(lastState);
    }
  }
</script>
