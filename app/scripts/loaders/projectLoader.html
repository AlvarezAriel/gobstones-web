<link rel="import" href="loader.html">
<link rel="import" href="components/metadataLoader.html">
<link rel="import" href="components/codeLoader.html">
<link rel="import" href="components/libraryLoader.html">
<link rel="import" href="components/teacherLoader.html">
<link rel="import" href="components/initialBoardLoader.html">
<link rel="import" href="components/descriptionLoader.html">
<link rel="import" href="components/attires/projectAttireLoader.html">
<link rel="import" href="../jszip.html">
<link rel="import" href="../async.html">

<script>
  class ProjectLoader extends Loader {
    constructor() {
      super();

      this.EXTENSION = ".gbp";
      this.loaders = [
        new TeacherLoader,
        new LibraryLoader,
        new CodeLoader,
        new InitialBoardLoader
      ];

      // Loaders must understand:
      // shouldHandle(path);
      // readProjectContent(context, content);

      this.attireLoader = new ProjectAttireLoader("assets/attires/");
      this.metadataLoader = new MetadataLoader();
      this.descriptionLoader = new DescriptionLoader();
    }

    save(context) {
      const loaders = this._loadersForSaving();
      const files = _.flatMap(loaders, loader => loader.getFiles(context));

      const zip = new JSZip();
      files.forEach(file => {
        zip.file(file.name, file.content);
      });

      this.attireLoader.writeToZip(context, zip);

      zip.generateAsync({ type: "blob" }).then(content => {
        this._saveBlob(content, `${context.getProjectName()}${this.EXTENSION}`);
      });
    }

    read(context, event, callback) {
      const { file } = this._readLocalFile(event);
      this.readRawZip(context, file, callback);
    }

    readRawZip(context, file, callback) {
      JSZip.loadAsync(file).then(zip => {
        this.readRaw(context, zip, callback);
      }).catch((e) => {
        console.error(e);
        alert("The project is corrupted or has errors.");
        callback();
      });
    }

    readRaw(context, zip, callback) {
      context.reset();

      this._loadFilesWithLoaders(context, zip, this.loaders, () => {
        context.boards.removeFirstBoard();

        console.log("Reading attires...");
        this.attireLoader.readFromZip(context, zip, () => {
          this._loadFilesWithLoaders(context, zip, [this.metadataLoader, this.descriptionLoader], callback);
        });
      });
    }

    _loadersForSaving() {
      return this.loaders.concat(this.metadataLoader);
    }

    _loadFilesWithLoaders(context, zip, loaders, callback) {
      const actions = ZipUtils.readAlphabetically(zip).map(aFile => {
        return this._loadComponent.bind(this, context, loaders, aFile);
      });

      async.series(actions, callback);
    }

    _loadComponent(context, loaders, { relativePath, zipEntry }, callback) {
      let handled = false;
      loaders.forEach(loader => {
        const getContent = () => zipEntry.async("string");
        if (!loader.shouldHandle(relativePath)) return;

        console.log("Reading '" + relativePath + "'...");
        handled = true;
        getContent().then(content => {
          try {
            console.log("Using " + loader.constructor.name + "...");
            content = this._removeUtf8Bom(content);
            loader.readProjectContent(context, content);
          } catch(e) {
            console.error(loader, e);
            alert(`Hubo un error al cargar ${relativePath}`);
          }
          callback();
        });
      });

      if (!handled) callback();
    }

    _removeUtf8Bom(content) {
      return content.charCodeAt(0) === 0xfeff
        ? content.substr(1)
        : content;
    }
  }
</script>
