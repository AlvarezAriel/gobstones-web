<link rel="import" href="keyCodeAdapter.html">
<link rel="import" href="../keymaster.html">

<script>
  class InteractiveRunner {
    constructor(parser) {
      this.parser = parser;
      this.adapter = new KeyCodeAdapter();
      this.keys = [];

      key.filter = function filter(event) {
        var tagName = (event.target || event.srcElement).tagName;
        // return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
        return true;
      };
    }

    run({ ast, request, throttle, callbacks: { onResult, onStop } }) {
      const controller = this._interpret(ast, request, request);

      window.BUS.fire("interactive-run");

      const render = (result) => {
        if (!result.error) {
          onResult(result.board());
        } else {
          onResult(this._handleError(result, request.code));
          onStop("end");
        }
      };

      const renderTimeout = () => render(controller.onTimeout());

      const configureTimeout = () => {
        clearInterval(this.timeout);
        if (controller.timeout)
          this.timeout = setInterval(renderTimeout, controller.timeout);
      }

      render(controller.onInit());

      const boundKeys = controller.keys;
      boundKeys.forEach((it) => {
        const newKey = this.adapter.adapt(it);
        this.keys.push(newKey);

        key(newKey, () => {
          configureTimeout();
          const result = controller.onKey(it);
          render(result);
          return false;
        });
      });

      configureTimeout();
    }

    clear() {
      this.keys.forEach(it => key.unbind(it));
      this.keys = [];

      clearInterval(this.timeout);
    }

    _interpret({ program }, { initialState, code }) {
      return this.parser.interpret(program, initialState);
    }

    _handleError(e, code) {
      e.error.location = this.parser.getErrorLineAndMode(e.error, code);
      return e;
    }
  }
</script>
