<link rel="import" href="loader.html">
<link rel="import" href="components/metadataLoader.html">
<link rel="import" href="components/codeLoader.html">
<link rel="import" href="components/libraryLoader.html">
<link rel="import" href="components/teacherLoader.html">
<link rel="import" href="components/initialBoardLoader.html">
<link rel="import" href="components/attires/projectAttireLoader.html">
<link rel="import" href="../jszip.html">
<link rel="import" href="../async.html">

<script>
  class ProjectLoader extends Loader {
    constructor() {
      super();

      this.EXTENSION = ".gbp";
      this.loaders = [
        new CodeLoader,
        new LibraryLoader,
        new TeacherLoader,
        new InitialBoardLoader
      ];

      // Loaders must understand:
      // shouldHandle(path);
      // readProjectContent(context, content);

      this.attireLoader = new ProjectAttireLoader("attires/");
      this.metadataLoader = new MetadataLoader()
    }

    save(context) {
      const loaders = this.loaders.concat(this.metadataLoader);
      const files = _.flatMap(loaders, loader => loader.getFiles(context));

      const zip = new JSZip();
      files.forEach(file => {
        zip.file(file.name, file.content);
      });

      this.attireLoader.writeToZip(context, zip);

      zip.generateAsync({ type: "blob" }).then(content => {
        this._saveBlob(content, `${context.getProjectName()}${this.EXTENSION}`);
      });
    }

    read(context, event, callback) {
      const { file, fileName } = this._readLocalFile(event);

      JSZip.loadAsync(file).then(zip => {
        context.editor.reset();
        context.boards.reset();
        context.setProjectName(fileName);
        context.editor.setAsDirty();

        this._loadFilesWithLoaders(context, zip, this.loaders, () => {
          context.boards.removeFirstBoard();

          this.attireLoader.readFromZip(context, zip, () => {
            this._loadFilesWithLoaders(context, zip, [this.metadataLoader], callback);
          });
        });
      });
    }

    _loadFilesWithLoaders(context, zip, loaders, callback) {
      const actions = ZipUtils.readAlphabetically(zip).map(aFile => {
        return this._loadComponent.bind(this, context, loaders, aFile);
      });

      async.series(actions, callback);
    }

    _loadComponent(context, loaders, { relativePath, zipEntry }, callback) {
      let handled = false;
      loaders.forEach(loader => {
        const getContent = () => zipEntry.async("string");
        if (!loader.shouldHandle(relativePath)) return;

        handled = true;
        getContent().then(content => {
          loader.readProjectContent(context, content);
          callback();
        });
      });

      if (!handled) callback();
    }
  }
</script>
