<link rel="import" href="loader.html">
<link rel="import" href="components/metadataLoader.html">
<link rel="import" href="components/codeLoader.html">
<link rel="import" href="components/libraryLoader.html">
<link rel="import" href="components/teacherLoader.html">
<link rel="import" href="components/initialBoardLoader.html">
<link rel="import" href="components/attires/projectAttireLoader.html">
<link rel="import" href="../jszip.html">
<link rel="import" href="../async.html">

<script>
  class ProjectLoader extends Loader {
    constructor() {
      super();

      this.loaders = [
        new MetadataLoader,
        new CodeLoader,
        new LibraryLoader,
        new TeacherLoader,
        new InitialBoardLoader
      ];

      // Loaders must understand:
      // shouldHandle(path);
      // readProjectContent(context, content);

      this.attireLoader = new ProjectAttireLoader("attires/");
    }

    save(context) {
      const files = _.flatMap(this.loaders, loader => loader.getFiles(context));

      const zip = new JSZip();
      files.forEach(file => {
        zip.file(file.name, file.content);
      });

      this.attireLoader.writeToZip(context, zip);

      zip.generateAsync({ type: "blob" }).then(content => {
        this._saveBlob(content, `${context.getProjectName()}.gbp`);
      });
    }

    read(context, event, callback) {
      const { file, fileName } = this._readLocalFile(event);

      JSZip.loadAsync(file).then(zip => {
        context.boards.reset();
        context.setProjectName(fileName);
        context.editor.setAsDirty();

        const filesToProcess = [];
        zip.forEach((relativePath, zipEntry) => {
          filesToProcess.push({
            path: relativePath,
            action: this._loadComponent.bind(this, context, relativePath, zipEntry)
          });
        });

        const actions = _(filesToProcess)
          .sortBy("path")
          .map("action")
          .value();

        async.parallel(actions, () => {
          context.boards.removeFirstBoard();
          this.attireLoader.readFromZip(context, zip);
          callback();
        });
      });
    }

    _loadComponent(context, path, zipEntry, callback) {
      let handled = false;
      this.loaders.forEach(loader => {
        const getContent = () => zipEntry.async("string");
        if (!loader.shouldHandle(path)) return;

        handled = true;
        getContent().then(content => {
          loader.readProjectContent(context, content);
          callback();
        });
      });

      if (!handled) callback();
    }
  }
</script>
